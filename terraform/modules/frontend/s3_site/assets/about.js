import{D as H,F as L,G as $,H as v,I as G,J as F,K as T,L as V,a as l,j as s,M as B,N as q,O as J,f as m,P as K,Q,B as W}from"./index.js";import{a as _,f as X,d as E,c as C,b as w,e as h,h as Y,u as Z,n as ee,g as te}from"./create-slot-recipe-context.js";import{H as y}from"./index3.js";const A=e=>_()(e,["immediate","lazyMount","onExitComplete","present","skipAnimationOnMount","unmountOnExit"]);function ne(e,t){const{state:n,send:o,context:r}=e,a=n.matches("mounted","unmountSuspended");return{skip:!r.get("initial"),present:a,setNode(i){i&&o({type:"NODE.SET",node:i})},unmount(){o({type:"UNMOUNT"})}}}var oe=H({props({props:e}){return{...e,present:!!e.present}},initialState({prop:e}){return e("present")?"mounted":"unmounted"},refs(){return{node:null,styles:null}},context({bindable:e}){return{unmountAnimationName:e(()=>({defaultValue:null})),prevAnimationName:e(()=>({defaultValue:null})),present:e(()=>({defaultValue:!1})),initial:e(()=>({sync:!0,defaultValue:!1}))}},exit:["clearInitial","cleanupNode"],watch({track:e,prop:t,send:n}){e([()=>t("present")],()=>{n({type:"PRESENCE.CHANGED"})})},on:{"NODE.SET":{actions:["setupNode"]},"PRESENCE.CHANGED":{actions:["setInitial","syncPresence"]}},states:{mounted:{on:{UNMOUNT:{target:"unmounted",actions:["clearPrevAnimationName","invokeOnExitComplete"]},"UNMOUNT.SUSPEND":{target:"unmountSuspended"}}},unmountSuspended:{effects:["trackAnimationEvents"],on:{MOUNT:{target:"mounted",actions:["setPrevAnimationName"]},UNMOUNT:{target:"unmounted",actions:["clearPrevAnimationName","invokeOnExitComplete"]}}},unmounted:{on:{MOUNT:{target:"mounted",actions:["setPrevAnimationName"]}}}},implementations:{actions:{setInitial:({context:e})=>{e.get("initial")||queueMicrotask(()=>{e.set("initial",!0)})},clearInitial:({context:e})=>{e.set("initial",!1)},invokeOnExitComplete:({prop:e,refs:t})=>{e("onExitComplete")?.();const n=t.get("node");if(!n)return;const o=F(n),r=new o.CustomEvent("exitcomplete",{bubbles:!1});n.dispatchEvent(r)},setupNode:({refs:e,event:t})=>{e.get("node")!==t.node&&(e.set("node",t.node),e.set("styles",G(t.node)))},cleanupNode:({refs:e})=>{e.set("node",null),e.set("styles",null)},syncPresence:({context:e,refs:t,send:n,prop:o})=>{const r=o("present");if(r)return n({type:"MOUNT",src:"presence.changed"});const a=t.get("node");if(!r&&a?.ownerDocument.visibilityState==="hidden")return n({type:"UNMOUNT",src:"visibilitychange"});v(()=>{const i=x(t.get("styles"));e.set("unmountAnimationName",i),i==="none"||i===e.get("prevAnimationName")||t.get("styles")?.display==="none"||t.get("styles")?.animationDuration==="0s"?n({type:"UNMOUNT",src:"presence.changed"}):n({type:"UNMOUNT.SUSPEND"})})},setPrevAnimationName:({context:e,refs:t})=>{v(()=>{e.set("prevAnimationName",x(t.get("styles")))})},clearPrevAnimationName:({context:e})=>{e.set("prevAnimationName",null)}},effects:{trackAnimationEvents:({context:e,refs:t,send:n,prop:o})=>{const r=t.get("node");if(!r)return;const a=c=>{(c.composedPath?.()?.[0]??c.target)===r&&e.set("prevAnimationName",x(t.get("styles")))},i=c=>{const d=x(t.get("styles"));T(c)===r&&d===e.get("unmountAnimationName")&&!o("present")&&n({type:"UNMOUNT",src:"animationend"})},p=c=>{T(c)===r&&!o("present")&&n({type:"UNMOUNT",src:"animationcancel"})};r.addEventListener("animationstart",a),r.addEventListener("animationcancel",p),r.addEventListener("animationend",i);const u=L(r,{animationFillMode:"forwards"});return()=>{r.removeEventListener("animationstart",a),r.removeEventListener("animationcancel",p),r.removeEventListener("animationend",i),$(()=>u())}}}}});function x(e){return e?.animationName||"none"}V()(["onExitComplete","present","immediate"]);const j=(e={})=>{const{lazyMount:t,unmountOnExit:n,present:o,skipAnimationOnMount:r=!1,...a}=e,i=l.useRef(!1),p={...a,present:o,onExitComplete:X(e.onExitComplete)},u=E(oe,p),c=ne(u);c.present&&(i.current=!0);const d=!c.present&&!i.current&&t||n&&!c.present&&i.current,P=()=>({"data-state":c.skip&&r?void 0:o?"open":"closed",hidden:!c.present});return{ref:c.setNode,getPresenceProps:P,present:c.present,unmounted:d}},[b,S]=C({name:"PresenceContext",hookName:"usePresenceContext",providerName:"<PresenceProvider />"}),re=e=>{const{children:t,disabled:n}=e,[o,r]=l.useState(e.container?.current),a=l.useSyncExternalStore(ie,()=>!1,()=>!0),{getRootNode:i}=w();if(l.useEffect(()=>{r(()=>e.container?.current)},[e.container]),a||n)return s.jsx(s.Fragment,{children:t});const p=o??se(i);return s.jsx(s.Fragment,{children:l.Children.map(t,u=>B.createPortal(u,p))})},se=e=>{const t=e?.(),n=t.getRootNode();return q(n)?n:J(t).body},ie=()=>()=>{},[k,f]=C({name:"TooltipContext",hookName:"useTooltipContext",providerName:"<TooltipProvider />"}),O=l.forwardRef((e,t)=>{const n=f(),o=m(n.getArrowProps(),e);return s.jsx(h.div,{...o,ref:t})});O.displayName="TooltipArrow";const M=l.forwardRef((e,t)=>{const n=f(),o=m(n.getArrowTipProps(),e);return s.jsx(h.div,{...o,ref:t})});M.displayName="TooltipArrowTip";const R=l.forwardRef((e,t)=>{const n=f(),o=S(),r=m(n.getContentProps(),o.getPresenceProps(),e);return o.unmounted?null:s.jsx(h.div,{...r,ref:Y(o.ref,t)})});R.displayName="TooltipContent";const U=l.forwardRef((e,t)=>{const n=f(),o=m(n.getPositionerProps(),e);return S().unmounted?null:s.jsx(h.div,{...o,ref:t})});U.displayName="TooltipPositioner";const ae=e=>{const t=l.useId(),{getRootNode:n}=w(),{dir:o}=Z(),r={id:t,dir:o,getRootNode:n,...e},a=E(K,r);return Q(a,ee)},ce=e=>{const[t,{children:n,...o}]=A(e),r=ae(o),a=j(m({present:r.open},t));return s.jsx(k,{value:r,children:s.jsx(b,{value:a,children:n})})},le=e=>{const[t,{value:n,children:o}]=A(e),r=j(m({present:n.open},t));return s.jsx(k,{value:n,children:s.jsx(b,{value:r,children:o})})},D=l.forwardRef((e,t)=>{const n=f(),o=m(n.getTriggerProps(),e);return s.jsx(h.button,{...o,ref:t})});D.displayName="TooltipTrigger";const{withRootProvider:I,withContext:g}=te({key:"tooltip"});I(le);const pe=I(ce,{defaultProps:{lazyMount:!0,unmountOnExit:!0}}),ue=g(D,"trigger",{forwardAsChild:!0}),de=g(U,"positioner",{forwardAsChild:!0}),me=g(R,"content",{forwardAsChild:!0}),z=g(M,"arrowTip",{forwardAsChild:!0}),he=g(O,"arrow",{forwardAsChild:!0,defaultProps:{children:s.jsx(z,{})}}),fe=l.forwardRef(function(t,n){const{showArrow:o,children:r,disabled:a,portalled:i=!0,content:p,contentProps:u,portalRef:c,...d}=t;return a?r:s.jsxs(pe,{...d,children:[s.jsx(ue,{asChild:!0,children:r}),s.jsx(re,{disabled:!i,container:c,children:s.jsx(de,{children:s.jsxs(me,{ref:n,...u,children:[o&&s.jsx(he,{children:s.jsx(z,{})}),p]})})})]})});function N({content:e,children:t}){const[n,o]=l.useState(!1);return s.jsx(fe,{closeOnClick:!1,content:e,openDelay:0,open:n,onOpenChange:r=>o(r.open),children:s.jsx("a",{onClick:()=>o(!n),className:"dotted-underline",children:t})})}function Pe(){return s.jsxs(W,{w:{base:"100%",md:"80%"},mx:"auto",textAlign:"center",py:8,fontSize:{base:"md",md:"lg",lg:"xl"},lineHeight:{base:"1.6"},children:[s.jsx(y,{as:"h1",size:"3xl",mb:4,children:"Motivation"}),s.jsxs("p",{children:["As a Stepmania/ITG stamina stepartist, one of the few challenges they face is being able to ",s.jsx(N,{content:"assign a number to",children:"rate"})," their charts correctly, or at least in a fair manner. Currently, the best way to do so is to cross-reference other charts of ",s.jsx(N,{content:"basically how many measures of 16th notes before a break and how long the breaks are",children:"similar stream breakdowns"})," and rate their charts based on the other ones. However, these breakdowns aren't in one place, making this task a bit annoying.",s.jsx("br",{}),"The purpose of this site is to put the breakdowns of all ",s.jsx(N,{content:"stuff in East Coast Stamina and Stamina RPG",children:"known tournament stamina charts"})," into one place, making it easier to cross-reference other charts."]}),s.jsx("br",{}),s.jsx(y,{as:"h1",size:"3xl",mb:4,children:"Contact Info"}),s.jsxs("p",{children:["Email: ",s.jsx("a",{href:"mailto:erictran0x@gmail.com",children:"erictran0x@gmail.com"})]}),s.jsx("p",{children:s.jsx("a",{href:"https://github.com/erictran0x/itg-stamdb",children:"GitHub repo"})})]})}export{Pe as component};
