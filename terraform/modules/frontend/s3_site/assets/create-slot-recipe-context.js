import{a as o,U as Z,V as L,f as G,W as H,X as Q,Y as ee,Z as O,_,M as U,$ as te,a0 as D,a1 as re,a2 as ne,a3 as se,a4 as oe,o as z,d as F,j as V,v as Y,a5 as I,a6 as ce}from"./index.js";function ue(e,t){return`${e} returned \`undefined\`. Seems you forgot to wrap component within ${t}`}function B(e={}){const{name:t,strict:s=!0,hookName:r="useContext",providerName:u="Provider",errorMessage:a,defaultValue:p}=e,i=o.createContext(p);i.displayName=t;function x(){const v=o.useContext(i);if(!v&&s){const h=new Error(a??ue(r,u));throw h.name="ContextError",Z(Error,"captureStackTrace")&&L(Error.captureStackTrace)&&Error.captureStackTrace(h,x),h}return v}return[i.Provider,x,i]}const[Re,ve]=B({name:"EnvironmentContext",hookName:"useEnvironmentContext",providerName:"<EnvironmentProvider />",strict:!1,defaultValue:{getRootNode:()=>document,getDocument:()=>document,getWindow:()=>window}});function ae(...e){return t=>{const s=[];for(const r of e)if(typeof r=="function"){const u=r(t);typeof u=="function"&&s.push(u)}else r&&(r.current=t);if(s.length)return()=>{for(const r of s)r()}}}function ie(e){let t=Object.getOwnPropertyDescriptor(e.props,"ref")?.get,s=t&&"isReactWarning"in t&&t.isReactWarning;return s?e.ref:(t=Object.getOwnPropertyDescriptor(e,"ref")?.get,s=t&&"isReactWarning"in t&&t.isReactWarning,s?e.props.ref:e.props.ref||e.ref)}const A=e=>{const t=o.memo(o.forwardRef((s,r)=>{const{asChild:u,children:a,...p}=s;if(!u)return o.createElement(e,{...p,ref:r},a);if(!o.isValidElement(a))return null;const i=o.Children.only(a),x=ie(i);return o.cloneElement(i,{...G(p,i.props),ref:r?ae(r,x):x})}));return t.displayName=e.displayName||e.name,t},fe=()=>{const e=new Map;return new Proxy(A,{apply(t,s,r){return A(r[0])},get(t,s){const r=s;return e.has(r)||e.set(r,A(r)),e.get(r)}})},Ce=fe(),[he,Ne]=B({name:"LocaleContext",hookName:"useLocaleContext",providerName:"<LocaleProvider />",strict:!1,defaultValue:{dir:"ltr",locale:"en-US"}}),Se=()=>(e,t)=>t.reduce((s,r)=>{const[u,a]=s,p=r;return a[p]!==void 0&&(u[p]=a[p]),delete a[p],[u,a]},[{},{...e}]);var K=typeof globalThis.document<"u"?o.useLayoutEffect:o.useEffect;function W(e){const t=e().value??e().defaultValue,s=e().isEqual??Object.is,[r]=o.useState(t),[u,a]=o.useState(r),p=e().value!==void 0,i=o.useRef(u);i.current=p?e().value:u;const x=o.useRef(i.current);K(()=>{x.current=i.current},[u,e().value]);const v=C=>{const N=x.current,k=L(C)?C(N):C;e().debug&&console.log(`[bindable > ${e().debug}] setValue`,{next:k,prev:N}),p||a(k),s(k,N)||e().onChange?.(k,N)};function h(){return p?e().value:u}return{initial:r,ref:i,get:h,set(C){(e().sync?U.flushSync:te)(()=>v(C))},invoke(C,N){e().onChange?.(C,N)},hash(C){return e().hash?.(C)??String(C)}}}W.cleanup=e=>{o.useEffect(()=>e,[])};W.ref=e=>{const t=o.useRef(e);return{get:()=>t.current,set:s=>{t.current=s}}};function le(e){const t=o.useRef(e);return{get(s){return t.current[s]},set(s,r){t.current[s]=r}}}var de=(e,t)=>{const s=o.useRef(!1),r=o.useRef(!1);o.useEffect(()=>{if(s.current&&r.current)return t();r.current=!0},[...(e??[]).map(u=>typeof u=="function"?u():u)]),o.useEffect(()=>(s.current=!0,()=>{s.current=!1}),[])};function Ee(e,t={}){const s=o.useMemo(()=>{const{id:n,ids:c,getRootNode:f}=t;return H({id:n,ids:c,getRootNode:f})},[t]),r=(...n)=>{e.debug&&console.log(...n)},u=e.props?.({props:Q(t),scope:s})??t,a=pe(u),p=e.context?.({prop:a,bindable:W,scope:s,flush:J,getContext(){return x},getComputed(){return w},getRefs(){return R},getEvent(){return k()}}),i=X(p),x={get(n){return i.current?.[n].ref.current},set(n,c){i.current?.[n].set(c)},initial(n){return i.current?.[n].initial},hash(n){const c=i.current?.[n].get();return i.current?.[n].hash(c)}},v=o.useRef(new Map),h=o.useRef(null),C=o.useRef(null),N=o.useRef({type:""}),k=()=>({...N.current,current(){return N.current},previous(){return C.current}}),y=()=>({...g,matches(...n){return n.includes(g.ref.current)},hasTag(n){return!!e.states[g.ref.current]?.tags?.includes(n)}}),R=le(e.refs?.({prop:a,context:x})??{}),m=()=>({state:y(),context:x,event:k(),prop:a,send:q,action:d,guard:S,track:de,refs:R,computed:w,flush:J,scope:s,choose:b}),d=n=>{const c=L(n)?n(m()):n;if(!c)return;const f=c.map(l=>{const P=e.implementations?.actions?.[l];return P||D(`[zag-js] No implementation found for action "${JSON.stringify(l)}"`),P});for(const l of f)l?.(m())},S=n=>L(n)?n(m()):e.implementations?.guards?.[n](m()),E=n=>{const c=L(n)?n(m()):n;if(!c)return;const f=c.map(P=>{const j=e.implementations?.effects?.[P];return j||D(`[zag-js] No implementation found for effect "${JSON.stringify(P)}"`),j}),l=[];for(const P of f){const j=P?.(m());j&&l.push(j)}return()=>l.forEach(P=>P?.())},b=n=>re(n).find(c=>{let f=!c.guard;return ne(c.guard)?f=!!S(c.guard):L(c.guard)&&(f=c.guard(m())),f}),w=n=>{ee(e.computed,()=>"[zag-js] No computed object found on machine");const c=e.computed[n];return c({context:x,event:k(),prop:a,refs:R,scope:s,computed:w})},g=W(()=>({defaultValue:e.initialState({prop:a}),onChange(n,c){c&&(v.current.get(c)?.(),v.current.delete(c)),c&&d(e.states[c]?.exit),d(h.current?.actions);const f=E(e.states[n]?.effects);if(f&&v.current.set(n,f),c===_){d(e.entry);const l=E(e.effects);l&&v.current.set(_,l)}d(e.states[n]?.entry)}})),$=o.useRef(void 0),M=o.useRef(O.NotStarted);K(()=>{queueMicrotask(()=>{const f=M.current===O.Started;M.current=O.Started,r(f?"rehydrating...":"initializing...");const l=$.current??g.initial;g.invoke(l,f?g.get():_)});const n=v.current,c=g.ref.current;return()=>{r("unmounting..."),$.current=c,M.current=O.Stopped,n.forEach(f=>f?.()),v.current=new Map,h.current=null,queueMicrotask(()=>{d(e.exit)})}},[]);const T=()=>"ref"in g?g.ref.current:g.get(),q=n=>{queueMicrotask(()=>{if(M.current!==O.Started)return;C.current=N.current,N.current=n;let c=T();const f=e.states[c].on?.[n.type]??e.on?.[n.type],l=b(f);if(!l)return;h.current=l;const P=l.target??c;r("transition",n.type,l.target||c,`(${l.actions})`);const j=P!==c;j?U.flushSync(()=>g.set(P)):l.reenter&&!j?g.invoke(c,c):d(l.actions??[])})};return e.watch?.(m()),{state:y(),send:q,context:x,prop:a,scope:s,refs:R,computed:w,event:k(),getStatus:()=>M.current}}function X(e){const t=o.useRef(e);return t.current=e,t}function pe(e){const t=X(e);return function(r){return t.current[r]}}function J(e){queueMicrotask(()=>{U.flushSync(()=>e())})}var Pe=se(e=>e);function we(e,t={}){const{sync:s=!1}=t,r=me(e);return o.useCallback((...u)=>s?queueMicrotask(()=>r.current?.(...u)):r.current?.(...u),[s,r])}function me(e){const t=o.useRef(e);return t.current=e,t}function ge(e){const{key:t,recipe:s}=e,r=oe();return o.useMemo(()=>{const u=s||(t!=null?r.getSlotRecipe(t):{});return r.sva(structuredClone(u))},[t,s,r])}const xe=e=>e.charAt(0).toUpperCase()+e.slice(1),Me=e=>{const{key:t,recipe:s}=e,r=xe(t||s.className||"Component"),[u,a]=z({name:`${r}StylesContext`,errorMessage:`use${r}Styles returned is 'undefined'. Seems you forgot to wrap the components in "<${r}.Root />" `}),[p,i]=z({name:`${r}ClassNameContext`,errorMessage:`use${r}ClassNames returned is 'undefined'. Seems you forgot to wrap the components in "<${r}.Root />" `,strict:!1}),[x,v]=z({strict:!1,name:`${r}PropsContext`,providerName:`${r}PropsContext`,defaultValue:{}});function h(y){const{unstyled:R,...m}=y,d=ge({key:t,recipe:m.recipe||s}),[S,E]=o.useMemo(()=>d.splitVariantProps(m),[m,d]);return{styles:o.useMemo(()=>R?ce:d(S),[R,S,d]),classNames:d.classNameMap,props:E}}function C(y,R={}){const{defaultProps:m}=R,d=S=>{const E=v(),b=o.useMemo(()=>I(m,E,S),[E,S]),{styles:w,classNames:g,props:$}=h(b);return V.jsx(u,{value:w,children:V.jsx(p,{value:g,children:V.jsx(y,{...$})})})};return d.displayName=y.displayName||y.name,d}return{StylesProvider:u,ClassNamesProvider:p,PropsProvider:x,usePropsContext:v,useRecipeResult:h,withProvider:(y,R,m)=>{const{defaultProps:d,...S}=m??{},E=F(y,{},S),b=o.forwardRef((w,g)=>{const $=v(),M=o.useMemo(()=>I(d??{},$,w),[$,w]),{styles:T,props:q,classNames:n}=h(M),c=n[R],f=V.jsx(u,{value:T,children:V.jsx(p,{value:n,children:V.jsx(E,{ref:g,...q,css:[T[R],M.css],className:Y(M.className,c)})})});return m?.wrapElement?.(f,M)??f});return b.displayName=y.displayName||y.name,b},withContext:(y,R,m)=>{const d=F(y,{},m),S=o.forwardRef((E,b)=>{const{unstyled:w,...g}=E,$=a(),T=i()?.[R];return V.jsx(d,{...g,css:[!w&&R?$[R]:void 0,E.css],ref:b,className:Y(E.className,T)})});return S.displayName=y.displayName||y.name,S},withRootProvider:C,useStyles:a,useClassNames:i}};export{Se as a,ve as b,B as c,Ee as d,Ce as e,we as f,Me as g,ae as h,Pe as n,Ne as u};
